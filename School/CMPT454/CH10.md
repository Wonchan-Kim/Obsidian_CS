Tree indexes: binary search can be also costy

Pairs of the form <key, pointer> as index entries or just entries. Each index pages contains pointer more than the number of keys, each key serves as a separator for the contents of the pages pointed to by the pointer to its left and right. ![[Pasted image 20250911193016.png]]![[Pasted image 20250911193021.png]]
Index page is the minimum unit consisting index file. 
We can do a binary search of the index file to identify the page containing the first key value that satisfies the range selection and follow the pointer to the page containing the first data record with that key value. Then we can scan the file sequentially from that point to retrieve the other qualifying records. 

Entry in the index file will not contain every information contained in the page, likely to be much smaller than the size of a page, and only one such entry exists per page of the data file. Now the binary search on the index file is much faster than a binary search of the data file.

===Binary search still expensive!===

## ISAM - INDEX SEQUENTIAL ACCESS METHOD
![[Pasted image 20250911195529.png]]
ISAM structure is ===static===. Primary pages are pre-fixed. 
Each tree node is a disk page, and all the data resides in the leaf pages. 
This corresponds to an index that uses Alternative 1, using ![[Pasted image 20250911200147.png]]
It is also possible to create an index with Alternative 2 by storing the data records in the separate file and storing <key, rid> pairs in the leaf pages of the ISAM index. When the file is created, all leaf pages are allocated sequentially and sorted on the search key value. If Alternative 2 or 3 is used, the data records are created and sorted before allocating the leaf pages of the ISAM index. The non-leaf level pages are then allocated. If more pages than primary pages are allocated, allocation of additional pages are required. ![[Pasted image 20250911200758.png]]
Equality selection search, we start at the root node and determine which subtree to search by comparing the value in the search field of the given record with the key values in the node. 
For a range query, the starting point in the data(leaf) level is determined similarly, and data pages are then retrieved sequentially. For inserts and deletes, the over flow pages are used accordingly. ![[Pasted image 20250911202013.png]]
Deletion of an entry k* is handled by simply removing the entry. If this entry is on an overflow page, and the overflow page becomes empty, the page will then be removed. If the entry is on the primary page and deletion makes the primary page as it is, it serves as a place holder for future insertions. 

ISAM has therefore as inherent structural problem; long overflow chains could develop if a number of inserts are made to the same leaf. These significantly impact the time time to retrieve a record. 

## B+ Trees: A Dynamic Index Structure
![[Pasted image 20250911213339.png]]
Since the tree structure grows and shrinks dynamically, it is not feasible to allocate the leaf pages sequentially as in ISAM, where the set of primary leaf pages was static. To retrieve all leaf pages efficiently, we have to link them using page pointers, in form of ===doubly linked list===.
![[Pasted image 20250911213728.png]]
- Operations(insert, delete) on the three keep it balanced
- A minimum occupancy of 50% is guaranteed for each node except for the root. 
- Searching for a record requires just a traversal from the root to the appropriate leaf. Refer to the length of a path from the root to a leaf(any leaf) as the tree is balanced. 
B+ Trees is the structure in that every node contains m entires, where d <= m <= 2d. d is a parameter of the tree, called the order of the tree, and is a measure of the capacity of a tree node. The root node is the only exception. 

### Format of the node
Same as ISAM ![[Pasted image 20250911193016.png]]
Pointer Pi points to the subtree in which all key values K are such that Ki <= K < Ki+1. As special cases, P0 points to a tree in which all key values are less than K1 and Pm points to a tree in which all key values are greater or equal than Km. 

Leaf nodes, denoted as k*. only leaf nodes contain data entries. 
If alternative (2) and (3) is used, leaf entries are <K, I(K)> pairs, just like non-leaf entires. Regardless of the alternative chosen for leaf entries, the leaf pages are chained together in a DDL.

### Search
```
find(searchkey K) returns nodepointer
return tree_search(root,K)
end find

tree_search(root, K) returns nodepointer
if *nodepointer is a leaf, return nodepointer
else
	if K < K1 then return tree_search(Po, K)
	else
		if K >= Km then return tree_search(Pm, K)
		else
			find i such that Ki <= K < Ki+1
			return tree_search(Pi, K)
end tree_search
```
![[Pasted image 20250911222817.png]]
With this example, d = 2, meaning that each node contains between 2 and 4 entries. Each non leaf entry is a <key value, node pointer> pair. The leaf level nodes' entries are data records denoted by k*. 

### Insert
The main idea is to recursively insert the entry by calling the insert algorithm on the appropriate chile node. In case of the node is full, the insertion causes the split. When the node is split, an entry pointing to the node created by the split must be inserted into its parent. If the root is split, a new root node is created and the height of the three increases by 1. 
![[Pasted image 20250911222817.png]]
Using the same example tree, think of case inserting 8 into the tree. 8 will belong to the left most node, which is already full, indicating the split is required. 