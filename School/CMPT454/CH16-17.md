ACID
Atomicity: either all actions in a Xact happen or none happens
Consistency: if initial DB starts consistent, it ends up consistent
Isolation: if X aborts, other Xacts are not affected, as if aborted X never happens.
Durability: If X commits, its W(A) effect must persist, even in case of system crash

X can be incomplete for reasons: transactions can be aborted, or terminated unsuccessfully, by the DBMS as anomaly arises during execution. If transaction is aborted, automatically restarted and execute new. System might crash(power supply) while X in progress. A transaction may encounter unexpected situation(read an unexpeted data value or be unable to access some disk) and decide to abort. 
DMBS ensures atomicity by undoing the actions of incomplete transactions. To maintain this, the DBMS maintains a record(log), of all writes to database. Log is also used for the durability, if the system crashes before the changes made by a complete transactions are written to a disk, the log is used to remember and restore these changes when the system restarts. 

![[Pasted image 20251119120634.png]]
![[Pasted image 20251119121014.png]]
![[Pasted image 20251119121428.png]]
![[Pasted image 20251119122502.png]]![[Pasted image 20251119122526.png]]

Concurrent: 1) improve throughput(CPU can process another X while Reading) 2) short X can be completed quickly

Serializability: Database instant that results from executing the given Schedule identical to the database instance that results from executing the transactions in some serial order. ![[Pasted image 20251119124743.png]]
T1's r/w of B is not influenced by T2's actions on A. Net effect is the same if these actions are swapped to obtain the serial schedule T1, T2. 
![[Pasted image 20251119125233.png]]
16.3 also serializable to T2-T1. 
IF T1 and T2 are submitted concurrently to DBMS, either of these schedules could be chosen. 

Aborted transactions?


Anomalies- Two actions on the same data object if at least one of them is a write. Actions of two transactions T1 and T2 conflict with each other. WR, RW, WW. 
WR: T2 read database object A modified by T1, which has not yet committed. Dirty read. 
	ex: T1 A->B 100. T2 increments both 6%. T1 B+100. 
	Interleaved as follows
	![[Pasted image 20251119131216.png]]
	Value of A written by T1 is read by T2 before T1 has completed all its changes. 
	Problem: T1 may write some value into A that makes the database inconsistent. As long as T1 overwrites this value with a correct value of A before committing, no harm is done if T1 and T2 rub in some serial order. 
RW: 
WW:

Cascading aborts:
W1R2: T1 aborts, remembered value must be restored, must abort T2 as well. 
W1W2: T1 aborts, remembered value must be restored, T2's write is lost, so must abort T2 as well.
In both, T2 depends on T1 so T1 aborts -> T2 aborts. 
R1W2 does not cause cascading abort. 
Why? T1 aborts, nothing to restore. 

Avoid cascading aborts:
ACA T2 depends on T1 only after T1 commits to eliminate the dependency on uncommitted X. 
So if T1 aborts, T2 can abort as well. 

Recoverable: If T2 depends on T1, T2 does not commit before T1 commits. So if T1 aborts, T2 can abort as well. ![[Pasted image 20251124132625.png]]

Recoverable. 
![[Pasted image 20251124132639.png]]
not recoverable. 

ACA -> Recoverable. not vice versa. 


| T1  | T2  |
| --- | --- |
| Wx  |     |
|     | Ry  |
| Ry  |     |
| C   |     |
|     | Rx  |
ACA. T2 depends on T1 by W-R. 


| T1  | T2  |
| --- | --- |
| Wx  |     |
|     | Ry  |
| Ry  |     |
|     | Rx  |
| C   |     |
not ACA, but recoverable. 
if no C, 


| T1  | T2  | T3  |
| --- | --- | --- |
| Rx  |     |     |
|     | Wx  |     |
| Wy  |     |     |
|     |     | Wx  |
| C   |     |     |
|     | C   |     |
|     |     | C   |
Serializable: T1T2T3
Conflict Serializable: T1->T2->T3. 
not ACA
Recoverable

| T1  | T2  | T3  |
| --- | --- | --- |
| Rx  |     |     |
|     | Wx  |     |
| Wy  |     |     |
|     |     | Wx  |
| C   |     |     |
|     | A   |     |
|     |     | C   |

Enforcing Consistency and Isolation

By having every participating X follow some protocol

2PL (2 phase locking) ensures conflict serializability
strict 2PL ensures conflict serializability and ACA
both based on lock mechanisms

Lock mechanism:
before R(A), first obtain shared lock, which prevents other X to write A.
before W(A), first obtain exclusive lock, which prevents other X to read or write
Release the lock after W and R. 
If failed to obtain a lock, X will wait for the lock to be released

![[Pasted image 20251124152334.png]]
why R1(b) gets S-lock? not W2(b)? T2 is already on the wait queue. 

![[Pasted image 20251124153138.png]]
2PL two phase locking
all unlocks must be after all locks
ensure conflict serializability
equivalent to the order of lock point. the time a Xact obtains all required locks. 

Example 2PL
T1: W(A) R(B)
T2: R(A) W(B)

![[Pasted image 20251124171457.png]]
Equivalent to T1T2 but not ACA, T2 depends on uncommitted T1, W(a)


Strict 2PL: for each X:
(a) shared lock
(b) exclusive lock
(c) hold all locks until commit

(c) prevents dependency on uncommitted X. Ensure both conflict serializability and ACA.

Example strict 2PL
![[Pasted image 20251124171748.png]]
Equivalent to T1T2.
ACA T2 depends only on committed T1 by holding locks until commit

![[Pasted image 20251124172026.png]]
ACA: T1 holds all locks until after commit
concurrency allowed for non-shared object C.

![[Pasted image 20251124172100.png]]


| T1  | T2  | T3  |
| --- | --- | --- |
|     | Ra  |     |
| Wa  |     |     |
|     | Wa  |     |
|     |     | Ra  |
| Ra  |     |     |
strict 2PL?
T2 holds shared lock and X lock until after W2(a), it is not possible to execute W1(A) prior to that point. 


![[Pasted image 20251124172842.png]]
