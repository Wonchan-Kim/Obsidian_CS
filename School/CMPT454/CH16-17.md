ACID
Atomicity: either all actions in a Xact happen or none happens
Consistency: if initial DB starts consistent, it ends up consistent
Isolation: if X aborts, other Xacts are not affected, as if aborted X never happens.
Durability: If X commits, its W(A) effect must persist, even in case of system crash

X can be incomplete for reasons: transactions can be aborted, or terminated unsuccessfully, by the DBMS as anomaly arises during execution. If transaction is aborted, automatically restarted and execute new. System might crash(power supply) while X in progress. A transaction may encounter unexpected situation(read an unexpeted data value or be unable to access some disk) and decide to abort. 
DMBS ensures atomicity by undoing the actions of incomplete transactions. To maintain this, the DBMS maintains a record(log), of all writes to database. Log is also used for the durability, if the system crashes before the changes made by a complete transactions are written to a disk, the log is used to remember and restore these changes when the system restarts. 

![[Pasted image 20251119120634.png]]
![[Pasted image 20251119121014.png]]
![[Pasted image 20251119121428.png]]
![[Pasted image 20251119122502.png]]![[Pasted image 20251119122526.png]]

Concurrent: 1) improve throughput(CPU can process another X while Reading) 2) short X can be completed quickly

Serializability: Database instant that results from executing the given Schedule identical to the database instance that results from executing the transactions in some serial order. ![[Pasted image 20251119124743.png]]
T1's r/w of B is not influenced by T2's actions on A. Net effect is the same if these actions are swapped to obtain the serial schedule T1, T2. 
![[Pasted image 20251119125233.png]]
16.3 also serializable to T2-T1. 
IF T1 and T2 are submitted concurrently to DBMS, either of these schedules could be chosen. 

Aborted transactions?


Anomalies- Two actions on the same data object if at least one of them is a write. Actions of two transactions T1 and T2 conflict with each other. WR, RW, WW. 
WR: T2 read database object A modified by T1, which has not yet committed. Dirty read. 
	ex: T1 A->B 100. T2 increments both 6%. T1 B+100. 
	Interleaved as follows
	![[Pasted image 20251119131216.png]]
	Value of A written by T1 is read by T2 before T1 has completed all its changes. 
	Problem: T1 may write some value into A that makes the database inconsistent. As long as T1 overwrites this value with a correct value of A before committing, no harm is done if T1 and T2 rub in some serial order. 
RW: 